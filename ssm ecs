AWSTemplateFormatVersion: '2010-09-09'
Description: |
  A scheduled Lambda that regenerates and shares two SSM Automation Runbooks for ECS?one for task status and one for stopping tasks? per cluster, with dynamic dropdowns of all services and tasks.

Parameters:
  SSMTagKey:
    Type: String
    Default: SSMRunbook
    Description: The ECS resource tag key to filter on
  SSMTagValue:
    Type: String
    Default: 'true'
    Description: The ECS resource tag value to filter on
  MonitoringAccount:
    Type: String
    Description: AWS Account ID to share the SSM documents with
  TargetAccounts:
    Type: CommaDelimitedList
    Description: Comma-separated list of account IDs for multi-account execution
  ExecutionRoleName:
    Type: String
    Description: IAM role name that SSM Automation will assume in target accounts

Resources:

  SSMRunbookLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ssm-runbook-generator-role-${AWS::StackName}
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: LambdaAutomationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecs:ListClusters
                  - ecs:ListServices
                  - ecs:ListTasks
                  - ecs:DescribeTasks
                  - ecs:ListTagsForResource
                  - resourcegroupstaggingapi:GetResources
                Resource: '*'
              - Effect: Allow
                Action:
                  - ssm:CreateDocument
                  - ssm:UpdateDocument
                  - ssm:ListDocumentVersions
                  - ssm:UpdateDocumentDefaultVersion
                  - ssm:ModifyDocumentPermission
                Resource: !Sub arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:document/SSM-ECS-*

  SSMRunbookGeneratorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ssm-runbook-generator-${AWS::StackName}
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt SSMRunbookLambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          SSM_TAG_KEY: !Ref SSMTagKey
          SSM_TAG_VALUE: !Ref SSMTagValue
          MONITORING_ACCOUNT: !Ref MonitoringAccount
          TARGET_ACCOUNTS: !Join
            - ','
            - !Ref TargetAccounts
          EXECUTION_ROLE_NAME: !Ref ExecutionRoleName
      Code:
        ZipFile: |
          import os, json, logging
          import boto3
          from botocore.exceptions import ClientError

          logger = logging.getLogger(__name__)
          logger.setLevel(logging.INFO)

          ecs = boto3.client('ecs')
          ssm = boto3.client('ssm')

          TAG_KEY       = os.environ['SSM_TAG_KEY']
          TAG_VALUE     = os.environ['SSM_TAG_VALUE']
          MONITOR_ACC   = os.environ['MONITORING_ACCOUNT']
          EXEC_ROLE     = os.environ['EXECUTION_ROLE_NAME']
          PREFIX_STATUS = 'SSM-ECS-Status'
          PREFIX_STOP   = 'SSM-ECS-Stop'

          def get_tagged_clusters_services():
              """Returns { cluster: [svc1, svc2?], ? } for services tagged KEY=VALUE."""
              out = {}
              for c_page in ecs.get_paginator('list_clusters').paginate():
                  for arn in c_page.get('clusterArns', []):
                      cluster = arn.split('/')[-1]
                      svcs = []
                      for s_page in ecs.get_paginator('list_services').paginate(cluster=cluster):
                          svcs.extend(s_page.get('serviceArns', []))
                      tagged = []
                      for svc_arn in svcs:
                          tags = ecs.list_tags_for_resource(resourceArn=svc_arn).get('tags', [])
                          if any(t['key']==TAG_KEY and t['value']==TAG_VALUE for t in tags):
                              tagged.append(svc_arn.split('/')[-1])
                      if tagged:
                          out[cluster] = sorted(tagged)
              return out

          def gather_tasks_for_cluster(cluster, services):
              """Return sorted list of *all* task IDs across all services in this cluster."""
              tasks = []
              for svc in services:
                  for t_page in ecs.get_paginator('list_tasks').paginate(cluster=cluster, serviceName=svc):
                      for t in t_page.get('taskArns', []):
                          tasks.append(t.split('/')[-1])
              return sorted(set(tasks))

          def build_doc(doc_type, cluster, services, tasks):
              """Construct SSM Automation doc JSON for status or stop."""
              base = {
                  "schemaVersion": "0.3",
                  "description": "",
                  "parameters": {},
                  "mainSteps": []
              }
              if doc_type == 'status':
                  base["description"] = f"ECS Task Status for {cluster}"
                  base["parameters"] = {
                      "Cluster": {"type":"String","description":"ECS cluster","default":cluster,"allowedValues":[cluster]},
                      "Service": {"type":"String","description":"ECS service","allowedValues":services},
                      "Task":    {"type":"String","description":"ECS task","allowedValues":tasks}
                  }
                  base["mainSteps"] = [{
                      "name":"describeTasks",
                      "action":"aws:executeAwsApi",
                      "inputs":{
                          "Service":"ecs",
                          "Api":"describeTasks",
                          "Cluster":cluster,
                          "tasks":["{{ Task }}"]
                      }
                  }]
              else:
                  base["description"] = f"ECS Stop Task for {cluster}"
                  base["parameters"] = {
                      "Cluster": {"type":"String","description":"ECS cluster","default":cluster,"allowedValues":[cluster]},
                      "Service": {"type":"String","description":"ECS service","allowedValues":services},
                      "Task":    {"type":"String","description":"ECS task","allowedValues":tasks}
                  }
                  base["mainSteps"] = [{
                      "name":"stopTask",
                      "action":"aws:executeAwsApi",
                      "inputs":{
                          "Service":"ecs",
                          "Api":"stopTask",
                          "Cluster":cluster,
                          "Task":"{{ Task }}"
                      }
                  }]
              return base

          def upsert_doc(name, content):
              payload = json.dumps(content)
              try:
                  ssm.create_document(Name=name, Content=payload, DocumentType='Automation', DocumentFormat='JSON')
                  logger.info(f"Created {name}")
              except ssm.exceptions.DocumentAlreadyExists:
                  try:
                      ssm.update_document(Name=name, Content=payload, DocumentFormat='JSON')
                      logger.info(f"Updated {name}")
                  except ClientError as e:
                      if e.response['Error']['Code']=='DuplicateDocumentContent':
                          logger.info(f"No changes for {name}")
                      else:
                          logger.error(f"Failed updating {name}", exc_info=True)
                          raise

          def share_doc(name):
              try:
                  ssm.modify_document_permission(Name=name, PermissionType='Share', AccountIdsToAdd=[MONITOR_ACC])
                  logger.info(f"Shared {name} to {MONITOR_ACC}")
              except ClientError as e:
                  if e.response['Error']['Code']=='DuplicatePermission':
                      logger.info(f"Already shared {name}")
                  else:
                      logger.error(f"Failed sharing {name}", exc_info=True)
                      raise

          def handler(event, context):
              logger.info(f"Start ? {context.aws_request_id}")
              cs_map = get_tagged_clusters_services()
              logger.info(f"Clusters?Services: {cs_map}")

              for cluster, services in cs_map.items():
                  tasks = gather_tasks_for_cluster(cluster, services)
                  logger.info(f"{cluster} ? services={services}, tasks={tasks}")

                  name_status = f"{PREFIX_STATUS}-{cluster}"
                  name_stop   = f"{PREFIX_STOP}-{cluster}"

                  doc_status = build_doc('status', cluster, services, tasks)
                  doc_stop   = build_doc('stop',   cluster, services, tasks)

                  upsert_doc(name_status, doc_status); share_doc(name_status)
                  upsert_doc(name_stop,   doc_stop);   share_doc(name_stop)

              logger.info("Done")
              return {"status":"completed"}

  RunbookScheduleRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub runbook-generator-schedule-${AWS::StackName}
      ScheduleExpression: rate(1 day)
      State: ENABLED
      Targets:
        - Id: RunbookGen
          Arn: !GetAtt SSMRunbookGeneratorFunction.Arn

  AllowEventsInvoke:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref SSMRunbookGeneratorFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt RunbookScheduleRule.Arn

Outputs:
  LambdaArn:
    Description: ARN of the runbook-generator Lambda
    Value: !GetAtt SSMRunbookGeneratorFunction.Arn
  RuleArn:
    Description: ARN of the EventBridge schedule rule
    Value: !GetAtt RunbookScheduleRule.Arn
