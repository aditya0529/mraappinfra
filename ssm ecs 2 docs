AWSTemplateFormatVersion: '2010-09-09'
Description: |
  A Lambda that (on demand) regenerates two SSM Automation documents per ECS cluster:
   • Stop All Tasks in all services
   • Select & Stop a single task via dropdowns

Parameters:
  SSMTagKey:
    Type: String
    Default: SSMRunbook
    Description: Tag key to filter ECS services
  SSMTagValue:
    Type: String
    Default: 'true'
    Description: Tag value to filter ECS services

Resources:

  SSMRunbookLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ssm-runbook-generator-role-${AWS::StackName}
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: LambdaAutomationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecs:ListClusters
                  - ecs:ListServices
                  - ecs:ListTasks
                  - ecs:DescribeTasks
                  - ecs:ListTagsForResource
                  - resourcegroupstaggingapi:GetResources
                Resource: '*'
              - Effect: Allow
                Action:
                  - ssm:CreateDocument
                  - ssm:UpdateDocument
                  - ssm:ListDocumentVersions
                  - ssm:UpdateDocumentDefaultVersion
                Resource: !Sub arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:document/SSM-ECS-*

  SSMRunbookGeneratorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ssm-runbook-generator-${AWS::StackName}
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt SSMRunbookLambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          SSM_TAG_KEY: !Ref SSMTagKey
          SSM_TAG_VALUE: !Ref SSMTagValue
      Code:
        ZipFile: |
          import os, json, logging
          import boto3
          from botocore.exceptions import ClientError

          logger = logging.getLogger(__name__)
          logger.setLevel(logging.INFO)

          ecs = boto3.client('ecs')
          ssm = boto3.client('ssm')

          TAG_KEY     = os.environ['SSM_TAG_KEY']
          TAG_VALUE   = os.environ['SSM_TAG_VALUE']
          PREFIX_ALL  = 'SSM-ECS-StopAll'
          PREFIX_SEL  = 'SSM-ECS-SelectStop'

          def get_tagged_clusters_services():
              """Returns { cluster: [svc1, svc2…] } for services tagged KEY=VALUE."""
              out = {}
              for c in ecs.get_paginator('list_clusters').paginate():
                  for arn in c.get('clusterArns', []):
                      cluster = arn.split('/')[-1]
                      svcs = []
                      for s in ecs.get_paginator('list_services').paginate(cluster=cluster):
                          svcs.extend(s.get('serviceArns', []))
                      tagged = [
                          svc_arn.split('/')[-1]
                          for svc_arn in svcs
                          if any(
                              t['key']==TAG_KEY and t['value']==TAG_VALUE
                              for t in ecs.list_tags_for_resource(resourceArn=svc_arn).get('tags', [])
                          )
                      ]
                      if tagged:
                          out[cluster] = sorted(tagged)
              return out

          def gather_tasks(cluster, services):
              """Return sorted list of unique task IDs across all services."""
              tasks = []
              for svc in services:
                  for p in ecs.get_paginator('list_tasks').paginate(cluster=cluster, serviceName=svc):
                      tasks.extend([t.split('/')[-1] for t in p.get('taskArns', [])])
              return sorted(set(tasks))

          def build_doc_stop_all(cluster, tasks):
              """Stop-All-Tasks doc: no parameters, one step per task."""
              return {
                  "schemaVersion": "0.3",
                  "description": f"Stop ALL tasks in cluster {cluster}",
                  "mainSteps": [
                      {
                          "name": f"stop_{t}",
                          "action": "aws:executeAwsApi",
                          "inputs": {
                              "Service": "ecs",
                              "Api": "stopTask",
                              "Cluster": cluster,
                              "Task": t
                          }
                      } for t in tasks
                  ]
              }

          def build_doc_select_stop(cluster, services, tasks):
              """Select-&-Stop doc: dropdowns for service and task."""
              return {
                  "schemaVersion": "0.3",
                  "description": f"Select & Stop Task in cluster {cluster}",
                  "parameters": {
                      "Cluster": {"type":"String","default":cluster,"allowedValues":[cluster]},
                      "Service": {"type":"String","allowedValues":services},
                      "Task":    {"type":"String","allowedValues":tasks}
                  },
                  "mainSteps": [{
                      "name": "stopTask",
                      "action": "aws:executeAwsApi",
                      "inputs": {
                          "Service": "ecs",
                          "Api": "stopTask",
                          "Cluster": cluster,
                          "Task": "{{ Task }}"
                      }
                  }]
              }

          def upsert_doc(name, content):
              payload = json.dumps(content)
              try:
                  ssm.create_document(
                    Name=name,
                    Content=payload,
                    DocumentType='Automation',
                    DocumentFormat='JSON'
                  )
                  logger.info(f"Created {name}")
              except ssm.exceptions.DocumentAlreadyExists:
                  try:
                      ssm.update_document(
                        Name=name,
                        Content=payload,
                        DocumentFormat='JSON'
                      )
                      logger.info(f"Updated {name}")
                  except ClientError as e:
                      if e.response['Error']['Code']=='DuplicateDocumentContent':
                          logger.info(f"No changes for {name}")
                      else:
                          logger.error(f"Failed updating {name}", exc_info=True)
                          raise

          def handler(event, context):
              logger.info("Starting runbook generation")
              cs = get_tagged_clusters_services()
              for cluster, svcs in cs.items():
                  tasks = gather_tasks(cluster, svcs)

                  # 1) stop-all
                  name_all = f"{PREFIX_ALL}-{cluster}"
                  doc_all  = build_doc_stop_all(cluster, tasks)
                  upsert_doc(name_all, doc_all)

                  # 2) select-&-stop
                  name_sel = f"{PREFIX_SEL}-{cluster}"
                  doc_sel  = build_doc_select_stop(cluster, svcs, tasks)
                  upsert_doc(name_sel, doc_sel)

              logger.info("Done")
              return {"status":"completed"}

Outputs:
  LambdaArn:
    Description: ARN of the runbook-generator function
    Value: !GetAtt SSMRunbookGeneratorFunction.Arn
